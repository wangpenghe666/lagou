函数式编程：

特性：纯函数，柯里化，函数组合等

面向过程编程：按照步骤实现，一步步实现

面向对象编程：现实实际中的事物抽象成程序中的类和对象，通过封装、继承、多态来演示事物联系

函数式编程：对运算过程进行抽象 ，函数式编程中的函数不是指的程序中的函数，
而是数学中的函数（映射关系），函数式编程描述数据（函数）之间的映射，函数式编程要有输入和输出

优点：代码重用

高阶函数：

定义：我们可以把函数作为参数传递给另一个函数，函数作为返回值

函数作为参数优点：灵活，不考虑内部实现，关注实现的目标
函数作为返回值的优点： 

数组的every方法是遍历数组每个值，看他每个值是否符合条件，一个不符合都是false
数组中的some方法是遍历数组每个值，看他有一个值是否符合条件，一个符合都是true

闭包
定义：函数和其周围的状态的引用捆绑在一起形成闭包，可以在另一个作用域中调用一个函数内部并访问到该函数作用域的成员
本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，
因此函数内部函数依然可以访问外部函数的成员
好处：延长作用域的范围

纯函数
定义：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用
纯函数就类似数学中的函数
优点：可缓存（提升性能），可测试（有输入和输出），不需要访问共享的数据，可以并行处理
缺点：全局变量，配置文件，数据库等会将函数变得不纯（全局变量，外部交互）

数组中的方法slice返回数组的指定部分，不会改变原数组 （纯函数）
数组中的splice对数组进行操作返回新的数组  （不是纯函数）

柯里化
定义：一个函数的时候只传入它的部分参数来调用它，返回一个新的函数（接受剩余参数）返回结果
优点：1、传递较少的参数，返回新函数，2、函数缓存，3、更灵活，4、多元函数转换成 一元函数

函数组合
定义：把细粒度的函数组合生成一个新的函数 （函数默认是从右到左执行）

lodash和lodash/fp模块中map方法的区别
lodash中的map接受的是三个参数，第一个是处理的每个元素，第二个是索引，第三个是数组
lodash/fp的map的函数参数只有一个参数，当前处理的元素

PointFree（函数的组合）
定义：不需要指明处理的数据，只需要合成运算的过程，需要定义一些辅助的基本运算函数


函子
总结：函数式编程的运算不直接操作值，而是由函子完成，函子就是实现了map契约对象，可以把函子想象成一个盒子，这个盒子
封装了一个值。想要处理盒子的值，需要给盒子传递一个函数（纯函数），由这个函数进行处理这个值，最终返回一个新值的盒子


folktale
of方法为了避免使用new来创建对象，更深层次是of方法用来把值放到上下文Context(把值放到容器中，使用map来处理值)

monad（单子）
一个函子如果有jion和of方法并遵守一些定律就是monad
map方法处理函子内部的值

函数式编程
运算过程抽象成函数


性能优化
内存：由可读写的单元，表示一片可操作空间
管理：人为的操作一片空间的申请，使用和释放
内存管理：开发者主动申请空间，使用空间和释放空间
管理流程：申请=》使用=》释放

javascript中的内存管理
申请 let obj = {}
使用  obj.ab ='dad'
释放 obj = null

javascript垃圾回收
javascript中的内存管理是自动的
对象不再被引用就是垃圾
对象不能从根上访问到时就是垃圾

javascript中的可达对象
可以访问到的对象就是可达对象（引用，作用域链）
可达的标准就是从根出发是否能被找到
javascript中的根就是可以理解为全局变量对象

GC算法
GC就是垃圾回收机制的简写
GC可以找到内存中的垃圾、并释放和回收空间

GC的垃圾
1、程序中不在需要使用的对象
2、程序中不能在访问的对象

引用计数算法
核心思想：设置引用数，判断当前引用数是否为0，引用数为0立即回收
优点：1、发现垃圾立即回收 2、最大限度减少程序暂停 （发现内存要暂满，找到垃圾回收释放空间）
缺点：1、 无法回收循环引用的对象 （不能回收）
      2、时间开销大、资源消耗大

标记清除算法
1、遍历所有对象找标记活动对象
2、遍历所有对象清除没有标记对象
优点：解决回收循环引用
缺点：地址不连续，空间碎片化，不能立即回收垃圾对象

标记整理
和标记清除类似，区别是进行了空间整理

优点：减少碎片化空间
缺点；不会立即回收垃圾对象

常见GC算法
1、引用计数
2、标记清除
3、标记整理

 V8引擎
主流的javascript执行引擎
V8采用即时编译（速度快）
V8内存设限（64位不超过1.5G，32位不超过800M）浏览器设置的，内存足够使用，垃圾回收机制的原因

V8垃圾回收
采用分代回收的思想
内存分为新生代、老生代
针对不同对象采用不同算法

V8回收新生代
小空间用于存储新生代对象（64位不超过32，32位不超过16M）
新生代指的是存活时间短的对象（例如局部作用域）
回收过程采用复制算法+标记整理
新生代内存区分为二个等大小的空间
使用空间为From，空闲空间为To
活动对象存储From空间
标记整理后将活动对象拷贝到To
From 与To交换空间完成释放
拷贝过程可能出现晋升，晋升就是将新生对象移至老生代，一轮GC还存活的对象新生代需要晋升，To空间的使用率超过25%

V8回收老生代
老生代对象存放在右侧老生代区域（64位不超过1.4G，32位不超过700M）
主要采用标记清除、标记整理、增量标记算法
采用标记整理进行空间优化
采用增量标记进行效率优化

新生代区域垃圾回收使用空间换时间
老生代区域垃圾回收不适合复制算法

内存问题的外在表现
页面出现延迟加载或者经常性暂停（网络正常的情况）
页面持续性出现糟糕的性能
页面的性能随时间延长越来越差

内存泄漏：内存使用持续升高
内存膨胀：在多数设备上都存在性能问题
频繁垃圾回收：通过内存变化图进行分析

监控内存的几种方式
1、浏览器任务管理器
2、Timeline时序图记录
3、堆快照查找分离DOM
4、判断是否存在频繁的垃圾回收

shift+esc会出现浏览器任务管理器

慎用全局变量 
1、作用域链的顶端
2、一直存在上下文执行栈，直到程序退出
3、同名变量会遮蔽或污染全局

dom缓存




